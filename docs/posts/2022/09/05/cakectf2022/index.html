<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="毎日眠いです。">
    
    
    <link rel="shortcut icon" href="https://hanazonochateau.net/favicon.ico">
    
    
    <link rel="stylesheet" href="https://hanazonochateau.net/css/style.min.css">

    <title>CakeCTF 2022 Writeup</title>

    <meta property="og:title" content="CakeCTF 2022 Writeup" />
<meta property="og:description" content="CakeCTF 2022 に DCDC として参加し、 その内の kiwi という問題を解きました。 楽しかった一方、自分にとっては難しい問題が多く、まだまだ力をつける必要があるなと感じました。
[rev] kiwi バイナリとダミーのflag.txt、それに接続先が提示されます。 バイナリを起動してみるとプロンプトが表示され、正しいキーを入力するとフラグが表示されるようです。
最初に種明かしをすると、有効なキーを入力すると、そのキーで暗号化されたフラグが出力されます。 まず有効なキーのパターンを解析し、その後暗号化されたフラグを復号化するという二段構成になっています。
解析にはGhidraを用いました。
有効なキーのパターンを見つける 入力されたキーが有効か判定し、それを用いているのは cakectf::EncryptionKey::decode です。
関数内部に set_key と set_magic という関数があり、この関数たちを呼び出すことで暗号化の準備が完成します。 Ghidraでデコンパイルするとif文が入り組んでおり、このif文をかいくぐってこれらの関数を呼び出すようなキーを入力する必要があります。
まずは前半部分です。
while( true ) { cVar2 = kiwi::ByteBuffer::readVarUint(bytebuf,&amp;local_34); if (cVar2 != &#39;\x01&#39;) { uVar3 = 0; goto LAB_00106145; } if (local_34 != 2) break; /* (1) */ cVar2 = kiwi::ByteBuffer::readVarUint(bytebuf,&amp;local_38); if (cVar2 != &#39;\x01&#39;) { uVar3 = 0; goto LAB_00106145; } local_28 = (Array&lt;unsigned_char&gt; *)set_key(this,mempool,local_38); /* (2) */ local_30 = (uchar *)kiwi::Array&lt;unsigned_char&gt;::begin(local_28); local_20 = (uchar *)kiwi::Array&lt;unsigned_char&gt;::end(local_28); for (; local_30 !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hanazonochateau.net/posts/2022/09/05/cakectf2022/" /><meta property="og:image" content="https://hanazonochateau.net/site_ogp.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-05T08:18:40+09:00" />
<meta property="article:modified_time" content="2022-09-05T08:18:40+09:00" />


    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://hanazonochateau.net/site_ogp.png"/>

<meta name="twitter:title" content="CakeCTF 2022 Writeup"/>
<meta name="twitter:description" content="CakeCTF 2022 に DCDC として参加し、 その内の kiwi という問題を解きました。 楽しかった一方、自分にとっては難しい問題が多く、まだまだ力をつける必要があるなと感じました。
[rev] kiwi バイナリとダミーのflag.txt、それに接続先が提示されます。 バイナリを起動してみるとプロンプトが表示され、正しいキーを入力するとフラグが表示されるようです。
最初に種明かしをすると、有効なキーを入力すると、そのキーで暗号化されたフラグが出力されます。 まず有効なキーのパターンを解析し、その後暗号化されたフラグを復号化するという二段構成になっています。
解析にはGhidraを用いました。
有効なキーのパターンを見つける 入力されたキーが有効か判定し、それを用いているのは cakectf::EncryptionKey::decode です。
関数内部に set_key と set_magic という関数があり、この関数たちを呼び出すことで暗号化の準備が完成します。 Ghidraでデコンパイルするとif文が入り組んでおり、このif文をかいくぐってこれらの関数を呼び出すようなキーを入力する必要があります。
まずは前半部分です。
while( true ) { cVar2 = kiwi::ByteBuffer::readVarUint(bytebuf,&amp;local_34); if (cVar2 != &#39;\x01&#39;) { uVar3 = 0; goto LAB_00106145; } if (local_34 != 2) break; /* (1) */ cVar2 = kiwi::ByteBuffer::readVarUint(bytebuf,&amp;local_38); if (cVar2 != &#39;\x01&#39;) { uVar3 = 0; goto LAB_00106145; } local_28 = (Array&lt;unsigned_char&gt; *)set_key(this,mempool,local_38); /* (2) */ local_30 = (uchar *)kiwi::Array&lt;unsigned_char&gt;::begin(local_28); local_20 = (uchar *)kiwi::Array&lt;unsigned_char&gt;::end(local_28); for (; local_30 !"/>

</head><body><header id="banner">
    <h2><a href="https://hanazonochateau.net/">花園シャトー107号室</a></h2>
    <nav>
        <ul>
            <li>
                <a href="https://hanazonochateau.net/posts" title="posts">posts</a>
            </li><li>
                <a href="https://hanazonochateau.net/575" title="575">575</a>
            </li><li>
                <a href="https://hanazonochateau.net/about" title="about">about</a>
            </li><li>
                <a href="https://hanazonochateau.net/comments" title="comments">comments</a>
            </li>
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>CakeCTF 2022 Writeup</h1>
            <div>
                <time>September 5, 2022</time>
                </div>
    </header><p>CakeCTF 2022 に <a href="https://dcdcnation.com/"  target="_blank" >DCDC</a> として参加し、 その内の kiwi という問題を解きました。
楽しかった一方、自分にとっては難しい問題が多く、まだまだ力をつける必要があるなと感じました。</p>
<h2 id="rev-kiwi">[rev] kiwi</h2>
<p>バイナリとダミーのflag.txt、それに接続先が提示されます。
バイナリを起動してみるとプロンプトが表示され、正しいキーを入力するとフラグが表示されるようです。</p>
<p>最初に種明かしをすると、有効なキーを入力すると、そのキーで暗号化されたフラグが出力されます。
まず有効なキーのパターンを解析し、その後暗号化されたフラグを復号化するという二段構成になっています。</p>
<p>解析にはGhidraを用いました。</p>
<h3 id="有効なキーのパターンを見つける">有効なキーのパターンを見つける</h3>
<p>入力されたキーが有効か判定し、それを用いているのは <code>cakectf::EncryptionKey::decode</code> です。</p>
<p>関数内部に <code>set_key</code> と <code>set_magic</code> という関数があり、この関数たちを呼び出すことで暗号化の準備が完成します。
Ghidraでデコンパイルするとif文が入り組んでおり、このif文をかいくぐってこれらの関数を呼び出すようなキーを入力する必要があります。</p>
<p>まずは前半部分です。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="k">while</span><span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cVar2</span> <span class="o">=</span> <span class="n">kiwi</span><span class="o">::</span><span class="n">ByteBuffer</span><span class="o">::</span><span class="n">readVarUint</span><span class="p">(</span><span class="n">bytebuf</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_34</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cVar2</span> <span class="o">!=</span> <span class="sc">&#39;\x01&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">LAB_00106145</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">local_34</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>  <span class="cm">/* (1) */</span>
      <span class="n">cVar2</span> <span class="o">=</span> <span class="n">kiwi</span><span class="o">::</span><span class="n">ByteBuffer</span><span class="o">::</span><span class="n">readVarUint</span><span class="p">(</span><span class="n">bytebuf</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_38</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cVar2</span> <span class="o">!=</span> <span class="sc">&#39;\x01&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">LAB_00106145</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">local_28</span> <span class="o">=</span> <span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">set_key</span><span class="p">(</span><span class="n">this</span><span class="p">,</span><span class="n">mempool</span><span class="p">,</span><span class="n">local_38</span><span class="p">);</span> <span class="cm">/* (2) */</span>
      <span class="n">local_30</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">kiwi</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;::</span><span class="n">begin</span><span class="p">(</span><span class="n">local_28</span><span class="p">);</span>
      <span class="n">local_20</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="p">)</span><span class="n">kiwi</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;::</span><span class="n">end</span><span class="p">(</span><span class="n">local_28</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">local_30</span> <span class="o">!=</span> <span class="n">local_20</span><span class="p">;</span> <span class="n">local_30</span> <span class="o">=</span> <span class="n">local_30</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* (3) */</span>
        <span class="n">local_18</span> <span class="o">=</span> <span class="n">local_30</span><span class="p">;</span>
        <span class="n">cVar2</span> <span class="o">=</span> <span class="n">kiwi</span><span class="o">::</span><span class="n">ByteBuffer</span><span class="o">::</span><span class="n">readByte</span><span class="p">(</span><span class="n">bytebuf</span><span class="p">,</span><span class="n">local_30</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cVar2</span> <span class="o">!=</span> <span class="sc">&#39;\x01&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">goto</span> <span class="n">LAB_00106145</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div><p><em>(1)</em> の部分から、 <code>set_key</code> にたどり着くには <code>readVarUint</code> で <code>local_34</code> に対して2を出力する必要がありそうです。
<code>readVarUint</code> は内部で <code>readByte</code> という関数を呼び出してwhileループしています。
実験したら、 <code>readVarUint</code> は2文字ずつ読んで数値に変換する関数のようでした。
したがって最初の2文字は <strong>02</strong> でよさそうです。</p>
<p><em>(2)</em> の <code>set_key</code> 内部は次のようになっています。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">EncryptionKey</span> <span class="o">*</span> <span class="n">__thiscall</span>
<span class="n">cakectf</span><span class="o">::</span><span class="n">EncryptionKey</span><span class="o">::</span><span class="n">set_key</span><span class="p">(</span><span class="n">EncryptionKey</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="n">MemoryPool</span> <span class="o">*</span><span class="n">param_1</span><span class="p">,</span><span class="n">uint</span> <span class="n">param_2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//(...snip...)
</span><span class="c1"></span>  
  <span class="o">*</span><span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)</span><span class="n">this</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)</span><span class="n">this</span> <span class="o">|</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">AVar2</span> <span class="o">=</span> <span class="n">kiwi</span><span class="o">::</span><span class="n">MemoryPool</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param_1</span><span class="p">,</span><span class="n">param_2</span><span class="p">);</span>

  <span class="c1">// (...snip...)
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">this</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>やってることは、EncryptionKey内部のフラグを立てるかなんかして、MemoryPoolにArrayを作っています。
<code>param_2</code> が要素数らしいです。</p>
<p>次の入力は要素数が入るらしいので、とりあえず <strong>08</strong> とかにしておきます。</p>
<p><em>(3)</em> のforループでさっきのArrayに値を読み込んで格納しているっぽいですね。
さっき要素数8にしたので、とりあえず8個分ゼロで埋めておきましょう。
<strong>0000000000000000</strong> で。</p>
<p><strong>0123456789abcdef</strong> とかでもいいのですが、後々面倒になります。
理由は読み進めるとわかります。</p>
<p>このwhile文にはもう用はないので <em>(1)</em> で2以外をあたえてbreakします。
何を与えるといいかというのは後半部に書いてあります。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="k">if</span> <span class="p">(</span><span class="n">local_34</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">local_34</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>         <span class="cm">/* (10) */</span>
        <span class="k">goto</span> <span class="n">LAB_00106145</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">local_34</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* (4) */</span>
        <span class="n">cVar2</span> <span class="o">=</span> <span class="n">kiwi</span><span class="o">::</span><span class="n">ByteBuffer</span><span class="o">::</span><span class="n">readVarUint</span><span class="p">(</span><span class="n">bytebuf</span><span class="p">,(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)(</span><span class="n">this</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cVar2</span> <span class="o">!=</span> <span class="sc">&#39;\x01&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">goto</span> <span class="n">LAB_00106145</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">set_magic</span><span class="p">(</span><span class="n">this</span><span class="p">,(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)(</span><span class="n">this</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">));</span> <span class="cm">/* (5) */</span>
        <span class="k">goto</span> <span class="n">LAB_00105fd5</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div><p><code>set_magic</code> にも入っておきたいので、 <em>(4)</em> から、次の値は <strong>01</strong> にしましょう。</p>
<p><em>(5)</em> の <code>set_magic</code> は次のようになっています。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="n">__thiscall</span> <span class="n">cakectf</span><span class="o">::</span><span class="n">EncryptionKey</span><span class="o">::</span><span class="n">set_magic</span><span class="p">(</span><span class="n">EncryptionKey</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="n">uint</span> <span class="o">*</span><span class="n">param_1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">*</span><span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)</span><span class="n">this</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)</span><span class="n">this</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)(</span><span class="n">this</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_1</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>EncryptionKey</code> の内部ビットを立てて、 <code>param_1</code> の値を <code>EncryptionKey</code> 内部にコピーしています。</p>
<p>さて、続きに何を入れるかですが、実は先の処理を見る必要があります。</p>
<p><code>main</code> 内部の続きの <code>checkMessage</code> 関数を見ます。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">undefined8</span> <span class="nf">checkMessage</span><span class="p">(</span><span class="n">EncryptionKey</span> <span class="o">*</span><span class="n">param_1</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">uint</span> <span class="n">uVar1</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">lVar2</span><span class="p">;</span>
  <span class="n">undefined8</span> <span class="n">uVar3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">piVar4</span><span class="p">;</span>
  <span class="n">Array</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
  
  <span class="n">lVar2</span> <span class="o">=</span> <span class="n">cakectf</span><span class="o">::</span><span class="n">EncryptionKey</span><span class="o">::</span><span class="n">magic</span><span class="p">(</span><span class="n">param_1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lVar2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">piVar4</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">cakectf</span><span class="o">::</span><span class="n">EncryptionKey</span><span class="o">::</span><span class="n">magic</span><span class="p">(</span><span class="n">param_1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">piVar4</span> <span class="o">==</span> <span class="mh">0xcafec4f3</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* (6) */</span>
      <span class="n">lVar2</span> <span class="o">=</span> <span class="n">cakectf</span><span class="o">::</span><span class="n">EncryptionKey</span><span class="o">::</span><span class="n">key</span><span class="p">(</span><span class="n">param_1</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lVar2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="n">this</span> <span class="o">=</span> <span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">cakectf</span><span class="o">::</span><span class="n">EncryptionKey</span><span class="o">::</span><span class="n">key</span><span class="p">(</span><span class="n">param_1</span><span class="p">);</span>
        <span class="n">uVar1</span> <span class="o">=</span> <span class="n">kiwi</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uVar1</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">uVar3</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">uVar3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><em>(6)</em> の <code>cafec4f3</code> がもう怪しすぎますね。</p>
<p><code>magic</code> 関数の戻り値が <code>cafec4f3</code> になればよさそうです。
<code>magic</code> 関数は以下のようになっています。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">EncryptionKey</span> <span class="o">*</span> <span class="n">__thiscall</span> <span class="n">cakectf</span><span class="o">::</span><span class="n">EncryptionKey</span><span class="o">::</span><span class="n">magic</span><span class="p">(</span><span class="n">EncryptionKey</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">EncryptionKey</span> <span class="o">*</span><span class="n">pEVar1</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)</span><span class="n">this</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pEVar1</span> <span class="o">=</span> <span class="p">(</span><span class="n">EncryptionKey</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">pEVar1</span> <span class="o">=</span> <span class="n">this</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">pEVar1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>EncryptionKey</code> の1ビット目が立っていればオフセット0x18の値を返し、そうでなければ0を返します。
このビットは <code>set_magic</code> で立ててあるので大丈夫です。</p>
<p>これより、次に入力する文字列は <code>cafec4f3</code> &hellip;かと思いきや、ちょっとひねりが入れてあります。
<code>readVarUint</code> を見てみましょう。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">undefined8</span> <span class="n">__thiscall</span> <span class="n">kiwi</span><span class="o">::</span><span class="n">ByteBuffer</span><span class="o">::</span><span class="n">readVarUint</span><span class="p">(</span><span class="n">ByteBuffer</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="n">uint</span> <span class="o">*</span><span class="n">param_1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// (...snip...)
</span><span class="c1"></span>
  <span class="n">local_11</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="o">*</span><span class="n">param_1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">cVar1</span> <span class="o">=</span> <span class="n">readByte</span><span class="p">(</span><span class="n">this</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_12</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cVar1</span> <span class="o">!=</span> <span class="sc">&#39;\x01&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">uVar2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">goto</span> <span class="n">LAB_00104ddd</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">param_1</span> <span class="o">=</span> <span class="o">*</span><span class="n">param_1</span> <span class="o">|</span> <span class="p">(</span><span class="n">local_12</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">local_11</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span> <span class="cm">/* (8) */</span>
    <span class="n">local_11</span> <span class="o">=</span> <span class="n">local_11</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>                                      <span class="cm">/* (9) */</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(((</span><span class="kt">char</span><span class="p">)</span><span class="n">local_12</span> <span class="o">&lt;</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">local_11</span> <span class="o">&lt;</span> <span class="mh">0x23</span><span class="p">));</span>
  <span class="n">uVar2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">LAB_00104ddd</span><span class="p">:</span>
  <span class="c1">// (...snip...)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><em>(8)</em> で読んだ数値を0x7fで論理積を取り、さらに <code>local_11</code> でシフトしています。
また <em>(9)</em> を見ると <code>local_11</code> は7ビットずつシフトしています。</p>
<p>これらを考慮に入れると、数値0xcafec4f3を <code>magic</code> 関数から出力させるには、計算すると、 <strong>f389fbd78c</strong> を入力する必要があることがわかります。
この辺は紙と鉛筆で計算しました。</p>
<p>最後に <code>decode</code> 関数を脱出するには <em>(10)</em> から <strong>00</strong> を入力します。</p>
<p>これまでの入力を合わせると、 <strong>0208000000000000000001f389fbd78c00</strong> となります。
これを入力すると、無事暗号化されたフラグが出力されます。</p>
<p>サーバに接続し、上記の入力をすると、以下のフラグが返ってきました。</p>
<pre tabindex="0"><code>bc9f9699b8aebf8380c5aa9ac0c195af9bdeb29c99d99fdb8992baa38c8d868cba81bbaeebb786aba3e2bbb0e7a0b5e1b5ffa3ab94afbffbb5bfb1acf2aca6bd
</code></pre><h3 id="暗号化されたフラグを復号する">暗号化されたフラグを復号する</h3>
<p>さて、暗号化されたフラグが手に入ったところで第二ラウンド開始です。
暗号化処理は <code>main</code> 内の <code>encryptFlag</code> で行っています。
以下がデコンパイル結果です。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">basic_string</span> <span class="o">*</span> <span class="nf">encryptFlag</span><span class="p">(</span><span class="n">basic_string</span> <span class="o">*</span><span class="n">enc_flag</span><span class="p">,</span><span class="n">Array</span> <span class="o">*</span><span class="n">raw_flag</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// (...snip...)
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;&gt;::</span><span class="n">vector</span>
            <span class="p">((</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">enc_flag</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">__cxx11</span><span class="o">::</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">char_traits</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;::</span><span class="n">size</span><span class="p">();</span>
                    <span class="cm">/* try { // try from 0010649e to 00106536 has its CatchHandler @ 00106541 */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;&gt;::</span><span class="n">reserve</span><span class="p">((</span><span class="n">ulong</span><span class="p">)</span><span class="n">enc_flag</span><span class="p">);</span>
  <span class="n">local_28</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">uVar3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">__cxx11</span><span class="o">::</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">char_traits</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;::</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uVar3</span> <span class="o">&lt;=</span> <span class="n">local_28</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">pcVar4</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">__cxx11</span><span class="o">::</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">char_traits</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;::</span>
                     <span class="n">operator</span><span class="p">[]((</span><span class="n">ulong</span><span class="p">)</span><span class="n">raw_flag</span><span class="p">);</span>
    <span class="n">cVar1</span> <span class="o">=</span> <span class="o">*</span><span class="n">pcVar4</span><span class="p">;</span>
    <span class="n">lVar5</span> <span class="o">=</span> <span class="n">kiwi</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;::</span><span class="n">data</span><span class="p">(</span><span class="n">in_RDX</span><span class="p">);</span> <span class="cm">/* (12) */</span>
    <span class="n">uVar2</span> <span class="o">=</span> <span class="n">kiwi</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">(</span><span class="n">in_RDX</span><span class="p">);</span>
    <span class="n">local_30</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="kt">int</span><span class="p">)((((</span><span class="n">uint</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)(</span><span class="n">local_28</span> <span class="o">%</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">uVar2</span> <span class="o">+</span> <span class="n">lVar5</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cVar1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">|</span>
                           <span class="p">(</span><span class="n">uint</span><span class="p">)(</span><span class="n">uint3</span><span class="p">)(</span><span class="n">cVar1</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">^</span> <span class="n">local_28</span><span class="p">;</span> <span class="cm">/* (11) */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;&gt;::</span><span class="n">emplace_back</span><span class="o">&lt;</span><span class="n">unsigned_long</span><span class="o">&gt;</span>
              <span class="p">((</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">unsigned_char</span><span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">)</span><span class="n">enc_flag</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_30</span><span class="p">);</span>
    <span class="n">local_28</span> <span class="o">=</span> <span class="n">local_28</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// (...snip...)
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">enc_flag</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>while内の <em>(11)</em> が暗号化処理の核です。</p>
<p><code>lVar5</code> と <code>uVar2</code> はコードをじっとにらむとあの <strong>0000000000000000</strong> のデータとサイズということがわかります。
また、 <code>(uint)*(byte *)(local_28 % (ulong)uVar2 + lVar5)</code> あたりは <code>lVar5[local_28 % (ulong)uVar2]</code> と見えます。
ここで <code>lVar5</code> は全て0なのでちょっと楽になり、
最終的には <code>((0 ^ cVar1) &amp; 0xff | (uint)(uint3)(cVar1 &gt;&gt; 7) &lt;&lt; 8) ^ 0xff) ^ i</code> (ここで <code>i</code> はループ変数)が暗号化処理だとわかります。</p>
<p>これらの情報を基に <code>solve.cpp</code> を書きました。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="n">string</span> <span class="n">enc_flag</span> <span class="o">=</span> <span class="s">&#34;bc9f9699b8aebf8380c5aa9ac0c195af9bdeb29c99d99fdb8992baa38c8d868cba81bbaeebb786aba3e2bbb0e7a0b5e1b5ffa3ab94afbffbb5bfb1acf2aca6bd&#34;</span><span class="p">;</span>

<span class="k">const</span> <span class="n">string</span> <span class="n">fake_flag</span> <span class="o">=</span> <span class="s">&#34;FakeCTF{***** REDUCTED *****}&#34;</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span> <span class="n">fake_enc_flag</span> <span class="o">=</span> <span class="s">&#34;b99f9699b8aebf83dddcdfded9d2a3b5abbbaeb8aeaec9c2cdcccfce9e&#34;</span><span class="p">;</span>

<span class="kt">uint8_t</span> <span class="nf">read_byte</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">enc</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">enc</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">enc</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">{</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">};</span>
    <span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">enc_flag_ref</span> <span class="o">=</span> <span class="n">enc_flag</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">enc_flag_ref</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">char</span> <span class="n">unenc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">enc</span> <span class="o">=</span> <span class="n">read_byte</span><span class="p">(</span><span class="n">enc_flag_ref</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mh">0x7f</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">enc</span> <span class="o">==</span> <span class="p">((((</span><span class="mi">0</span> <span class="o">^</span> <span class="n">c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">|</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">^</span> <span class="n">i</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">unenc</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">unenc</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>上記の <code>solve.cpp</code> をコンパイルし実行するとフラグゲットです。</p>
<p><code>CakeCTF{w3_n33d_t0_pr3v3nt_Google_fr0m_st4nd4rd1z1ng_ev3ryth1ng}</code></p>
<p>おしまい。</p>
</article>

        </main><footer id="footer" style="text-align: center;">
    <a href="https://forms.gle/Cc3R3fFMCQ9m6Rsr9" target="_blank">コメントはこちら</a>
    </br>
    Copyright © 2022 Totsugekitai
    </br>
    Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> and <a href="https://github.com/LukasJoswiak/etch"
        target="_blank">etch</a>
</footer></body>
</html>
